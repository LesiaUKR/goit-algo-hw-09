# goit-algo-hw-09

# Homework Greedy Algorithm and Dynamic Programming

### Результати тестування алгоритмів

|   Amount |   Функція жадібного алгоритму (s) |   Функція динамічного програмування (s) |
|---------:|:----------------------------------:|:----------------------------------------:|     
|       10 |                         0.0009261 |                               0.0173669 |     
|       55 |                         0.0017779 |                               0.129077  |     
|      113 |                         0.0013903 |                               0.24527   |     
|      207 |                         0.0009983 |                               0.335835  |     
|      505 |                         0.0011583 |                               0.671497  |     
|     1001 |                         0.0006973 |                               1.16434   |     


## 1. Жадібний алгоритм

**Опис:**

Жадібний алгоритм вибирає монети найбільшого номіналу, які можна використати, до того моменту, поки сума не буде повністю розподілена.

**Часова складність:**

- Перебір монет: Кожна монета перевіряється один раз, тому часова складність залежить від кількості монет у наборі.
- Випадкова сума: Залежить від того, як швидко сума буде розподілена за допомогою найбільших монет.

В середньому, часова складність жадібного алгоритму можна вважати O(n), де n — кількість монет у наборі. Однак для конкретних реалізацій ця складність може бути більш-менш залежно від набору монет і суми.

> [!NOTE]
> Жадібний алгоритм працює оптимально, коли номінали монет формують "задовільні" структури (наприклад, кратні один одному). Інакше його ефективність може бути знижена, і він може не знайти оптимальне рішення для всіх наборів монет.
    
## 2. Алгоритм динамічного програмування

**Опис:**

Алгоритм динамічного програмування використовує таблицю для зберігання мінімальної кількості монет, необхідних для досягнення кожної суми до заданої суми.

**Часова складність:**

- Ініціалізація: Ініціалізація масиву min_coins і coin_count займає O(m), де m — сума для розподілу.
- Заповнення таблиці: Для кожної монети і кожної суми до amount, алгоритм виконує перевірку і оновлення таблиці. Це має складність O(c * m), де c — кількість монет, а m — сума.

Таким чином, загальна часова складність алгоритму динамічного програмування є O(c * m), де c — кількість монет, а m — сума, для якої потрібно знайти розподіл.

> [!NOTE]
> Динамічне програмування завжди знаходить оптимальне рішення і є підходящим, якщо набір монет може бути будь-яким. Однак його часова складність може бути високою для великих сум, що вимагає більше обчислювальних ресурсів.

## Висновки:

**Жадібний алгоритм** зазвичай має меншу часову складність у порівнянні з динамічним програмуванням і є швидшим у простих випадках, де номінали монет дозволяють використовувати жадібний підхід. Проте, його ефективність може знижуватися при більш складних наборах монет.

**Динамічне програмування** забезпечує точний результат і підходить для будь-якого набору монет, але може мати вищу часову складність та вимагати більше пам'яті, особливо для великих сум.